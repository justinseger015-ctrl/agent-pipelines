# Code Review Pipeline
# Multi-perspective code review with synthesis and optional fixes

name: code-review
description: Review code from multiple perspectives, synthesize findings, optionally fix issues
version: 2

defaults:
  provider: claude-code
  model: sonnet

stages:
  # Stage 1: Gather context about what changed
  - name: gather-context
    description: Identify changed files and understand the scope
    runs: 1
    prompt: |
      Explore the codebase to understand recent changes.

      Run `git diff HEAD~5` or `git status` to see what's changed.
      Identify:
      - Key files that were modified
      - The nature of the changes (feature, fix, refactor)
      - Any patterns or areas of concern

      Write your findings to: ${OUTPUT}

      When complete, write status.json:
      ```bash
      cat > ${STATUS} << 'STATUSEOF'
      {"decision": "stop", "reason": "Context gathered", "summary": "Identified N changed files"}
      STATUSEOF
      ```

  # Stage 2: Multi-perspective review
  # Note: parallel execution not yet implemented - runs sequentially
  - name: review
    description: Review from 4 different perspectives
    runs: 4
    model: sonnet
    inputs:
      from: gather-context
      select: latest
    perspectives:
      - security vulnerabilities and data handling
      - performance implications and efficiency
      - code clarity, maintainability, and patterns
      - test coverage and edge cases
    prompt: |
      You are code reviewer #${ITERATION}, focusing on one perspective.

      Read context from the previous stage:
      ```bash
      jq -r '.inputs.from_stage["gather-context"][]' ${CTX} 2>/dev/null | while read file; do
        cat "$file"
      done
      ```

      Review the codebase from your perspective. Be thorough but concise.
      Focus on actionable findings, not style nitpicks.

      Format your output as:
      ## Review #${ITERATION}

      ### Critical Issues
      - ...

      ### Recommendations
      - ...

      ### Notes
      - ...

      Write to: ${OUTPUT}

      When complete, write status.json:
      ```bash
      cat > ${STATUS} << 'STATUSEOF'
      {"decision": "continue", "reason": "Review complete", "summary": "Reviewed from perspective ${ITERATION}"}
      STATUSEOF
      ```

  # Stage 3: Synthesize all reviews (fan-in)
  - name: synthesize
    description: Combine all reviews into prioritized action items
    runs: 1
    model: opus
    inputs:
      from: review
      select: all
    prompt: |
      You have received code reviews from different perspectives.

      Read all reviews:
      ```bash
      jq -r '.inputs.from_stage["review"][]' ${CTX} 2>/dev/null | while read file; do
        echo "=== Review: $file ==="
        cat "$file"
        echo ""
      done
      ```

      Synthesize these into a single prioritized report:

      1. Deduplicate overlapping findings
      2. Prioritize by severity (Critical > High > Medium > Low)
      3. Group related issues together
      4. Provide clear, actionable recommendations

      Format:
      ## Code Review Summary

      ### Critical (fix before merge)
      ...

      ### High Priority
      ...

      ### Medium Priority
      ...

      ### Low Priority / Nice to Have
      ...

      ### Overall Assessment
      [Ready to merge / Needs work / Major concerns]

      Write to: ${OUTPUT}

      When complete, write status.json:
      ```bash
      cat > ${STATUS} << 'STATUSEOF'
      {"decision": "stop", "reason": "Synthesis complete", "summary": "Prioritized N findings"}
      STATUSEOF
      ```

  # Stage 4: Optional - Fix issues iteratively
  - name: fix-issues
    description: Iteratively fix identified issues
    runs: 10
    termination:
      type: judgment
      consensus: 2
      min_iterations: 2
    inputs:
      from: synthesize
      select: latest
    prompt: |
      Read the code review synthesis:
      ```bash
      jq -r '.inputs.from_stage["synthesize"][]' ${CTX} 2>/dev/null | while read file; do
        cat "$file"
      done
      ```

      Read your progress so far:
      ```bash
      cat ${PROGRESS}
      ```

      Pick the highest priority unfixed issue and fix it:
      1. Read the relevant code
      2. Make the fix
      3. Verify it works
      4. Commit with a descriptive message

      Update ${PROGRESS} with:
      - What you fixed
      - Files changed
      - Any follow-up notes

      After fixing, write status.json:
      ```bash
      cat > ${STATUS} << 'STATUSEOF'
      {"decision": "continue", "reason": "More issues to fix", "summary": "Fixed issue X"}
      STATUSEOF
      ```
      Or if remaining issues are minor/cosmetic OR you've fixed all critical/high issues:
      ```bash
      cat > ${STATUS} << 'STATUSEOF'
      {"decision": "stop", "reason": "Critical issues resolved", "summary": "All high-priority fixes complete"}
      STATUSEOF
      ```
